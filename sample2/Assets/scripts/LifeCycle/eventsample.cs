using UnityEngine;
//유니티에서 사용되는 이벤트 함수 (생명주기)
//유니티에서는 스크립트의 실행, 활성화, 프레임 당 호출등
//상황에 맞게 작업할 숭 ㅣㅆ는 작업 공간이 존재

//tip) 프로그래밍에서 함수는 특정 하나의 기능을 수행하기 위해서 명령문들을 모아놓은 명령 집합체

public class eventsample : MonoBehaviour
{
    //스크립트 내에서 이벤트 함수를 작성하고, 내부에 진행할 명령문을 작성하면 상황에 맞게 해당 기능이 수행됨
    private void Awake()
    {
        Debug.Log("[Awake]");
        Debug.Log("씬이 시작될 때 한번만 호출되는 영역");
        Debug.Log("해당 스크립트가 비활성화되어 있어도 이 위치의 작업은 실행됨");
        Debug.Log("해당 영역에서 코루틴으로 실행이 불가");
        Debug.Log("각 스크립트 기준 한 번만 호출이 되고 다른 개체의 초기화가 완료가 된 후 호출 되는 영역이기 때문에 " +
            "다른 컴포넌트에 대한 참조를 만들어야 하는 경우 이 위치에서 만들면 안전하게 처리 됨");
        //코루틴(coroutine) : 코드를 일시 중지하고 특정 조건이 충족될때까지 실행을 delay 시킬수 있는 기능(ex. 3초 뒤에 오브젝트를 파괴)
    }

    private void OnEnable() // 반대 OnDisable()
    {
        Debug.Log("[OnEnable]");
        Debug.Log("해당 위치는 오브젝트 또는 스크립트가 활성화 될때 호출됨");
        Debug.Log("이벤트에 대한 연결에 사용됨");
        Debug.Log("해당 위치에서는 코루틴 사용이 불가합니다");
    }

    void Start()
    {
        Debug.Log("[Start]");
        Debug.Log("모든 스크립트의 Awake가 다 실행된 이후 실행되는 영역");
        Debug.Log("해당 영역에서는 코루틴에 대한 실행이 가능");
    }

    //awake, start의 공통점
    //둘 다 기본적으로 값에 대한 초기화(할당)를 수행하는 위치
    //어떤 것을 사용해도 상관 없으나 상황에 따라 설계함

    //awake : 변수 초기화, 값 참조
    //start : 게임 로직에 대한 실행, 초기화된 데이터를 기반으로 작업 수행, 코루틴 작업

    //해당 상황에 대한 판단을 위해 sample1, sample2 파일을 통한 예시로 확인

    void Update()
    {
        //화면에 렌더링 되는 주기가 1초에 약 60번정도 호출됨(하드웨어 성능에 따라 차이가 날수 있음)
        //time.deltatime을 통해 이전 프레임 ~ 현재 프레임까지의 시간 차이로 보정값을 주거나
        //정규화 / 단위 벡터를 이용해 작업을 처리합니다.
        //기본적으로 계산에 보정값들이 많이 사용됨

        //프로그램 내에서 핵심적으로 계속 사용되는 메인 로직을 짜는 위치로 사용
        //ex) 키 입력등을 기반으로 움직임(지속적인 업데이트가 요구되는 경우)

        //업데이트를 대체할수 있는 수단
        //1. 상황에 맞는 유니티 생명 주기 코드
        //2. 코루틴
        //3. 이벤트 시스템(버튼 클릭 / 충돌감지 등)
        //4. c#의 가상 함수 개념(update를 대신해 특정 클래스에서 업데이트 로직을 처리함)
        //   특정 하나의 관리 클래스(manager)에 update의 로직을 위임해 관리해서 사용

        //업데이트는 써야하는 기능이고, 가장많이 사용되는 영역
        //따라서 업데이트에서 무조건 실행되는 상황이 아니라면 다른 영역에서 작업을 하게 설계하는것이 업데이트 부담을 줄여줄수있고 이게 성능의 향상으로 이어짐
        // -> 업데이트의 사용을 피하면 피할수록 성능은 올라가긴 함. 제대로 알고 사용 할 것
    }

    private void FixedUpdate()
    {
        //일정한 발생 주기가 보장되어야 하는 로직에서 사용됩니다.
        //물리 연산 (rigidbody)이 적용된 오브젝트에 대한 조정
        //프레임을 기반으로 처리되는 것이 아닌 Fixed TimeStep이라는 설정된 값에 의해 일정 간격으로 호출됩니다.
        
        //*TimeScale이 0으로 설정된 경우 멈춤
    }

    private void LateUpdate()
    {
        //모든 update 함수(Update, FixedUpdate)가 호출된 다음에 마지막으로 호출되는 영역
        //후처리 과정에 사용
        //LateUpdate가 여러개일 경우 상황에 맞는 호출 순서가 중요
    }
}
